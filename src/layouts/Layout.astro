---
import { ViewTransitions } from "astro:transitions";
import SEOTags from "@/components/seo/SEOTags.astro";
import type { HeadTags } from "@/utils/types/HeadTags";
import Header from "../components/Header.astro";

import "@/styles/tailwind.css";
import "@/styles/post.css";

export type Props = HeadTags & {
	showHud?: boolean;
};

const { showHud = false, ...headTags } = Astro.props;
---

<!DOCTYPE html>
<html lang="en">
  <SEOTags {...headTags} />
  <body>
    <canvas class="stars" id="stars"></canvas>
    <div class="grain"></div>
    <div class="vignette"></div>
    <div class="crosshair"></div>

    {showHud && (
      <div class="hud">
        <div class="hud-coords">
          <span>RA 14h 29m 42.9s</span>
          <span>DEC +38&deg; 31' 18"</span>
        </div>
        <div class="hud-time" id="hud-time"></div>
        <div class="hud-status">Tracking &middot; Sidereal</div>
        <div class="hud-mag">Mag 6.2 &middot; Bortle 3</div>
      </div>
    )}

    <div class="page">
      <Header />
      <main>
        <slot />
      </main>
    </div>
  </body>
  <ViewTransitions />

  <script>
    function initStars() {
      const c = document.getElementById('stars') as HTMLCanvasElement;
      if (!c) return;
      const ctx = c.getContext('2d');
      if (!ctx) return;
      let w: number, h: number;

      function resize() {
        w = c.width = window.innerWidth;
        h = c.height = window.innerHeight;
      }
      resize();
      window.addEventListener('resize', resize);

      let mouseX = 0.5;
      let mouseY = 0.5;
      document.addEventListener('mousemove', function(e) {
        mouseX = e.clientX / window.innerWidth;
        mouseY = e.clientY / window.innerHeight;
      });

      const stars: { x: number; y: number; r: number; a: number; baseA: number; s: number; phase: number }[] = [];
      for (let i = 0; i < 250; i++) {
        stars.push({
          x: Math.random() * 2000,
          y: Math.random() * 2000,
          r: Math.random() * 1.2 + 0.3,
          a: Math.random() * 0.6 + 0.2,
          baseA: Math.random() * 0.6 + 0.2,
          s: Math.random() * 0.004 + 0.001,
          phase: Math.random() * Math.PI * 2
        });
      }

      class ShootingStar {
        x: number; y: number; vx: number; vy: number;
        life: number; maxLife: number; length: number; brightness: number;
        constructor(canvasW: number, canvasH: number) {
          this.x = Math.random() * canvasW;
          this.y = Math.random() * canvasH * 0.3;
          const angle = Math.PI * 0.2 + Math.random() * Math.PI * 0.3;
          const speed = 400 + Math.random() * 300;
          this.vx = Math.cos(angle) * speed;
          this.vy = Math.sin(angle) * speed;
          this.life = 0;
          this.maxLife = 0.5 + Math.random() * 0.5;
          this.length = 60 + Math.random() * 80;
          this.brightness = 0.6 + Math.random() * 0.4;
        }
        update(dt: number) {
          this.x += this.vx * dt;
          this.y += this.vy * dt;
          this.life += dt;
          return this.life < this.maxLife;
        }
        draw(drawCtx: CanvasRenderingContext2D) {
          const progress = this.life / this.maxLife;
          const alpha = this.brightness * (1 - progress * progress);
          if (alpha <= 0) return;
          const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
          const tailX = this.x - (this.vx * this.length / speed) * 0.15;
          const tailY = this.y - (this.vy * this.length / speed) * 0.15;
          const grad = drawCtx.createLinearGradient(tailX, tailY, this.x, this.y);
          grad.addColorStop(0, 'rgba(200,210,240,0)');
          grad.addColorStop(0.7, 'rgba(200,210,240,' + (alpha * 0.5) + ')');
          grad.addColorStop(1, 'rgba(220,230,255,' + alpha + ')');
          drawCtx.strokeStyle = grad;
          drawCtx.lineWidth = 1.5;
          drawCtx.beginPath();
          drawCtx.moveTo(tailX, tailY);
          drawCtx.lineTo(this.x, this.y);
          drawCtx.stroke();
          drawCtx.beginPath();
          drawCtx.arc(this.x, this.y, 1.5, 0, Math.PI * 2);
          drawCtx.fillStyle = 'rgba(255,255,255,' + alpha + ')';
          drawCtx.fill();
        }
      }

      const shootingStars: ShootingStar[] = [];
      let nextShootingStarTime = 2 + Math.random() * 3;
      let lastTime = performance.now();
      let animId: number;

      function draw(now: number) {
        const dt = Math.min((now - lastTime) / 1000, 0.1);
        lastTime = now;
        ctx!.clearRect(0, 0, w, h);
        const parallaxX = (mouseX - 0.5) * -4;
        const parallaxY = (mouseY - 0.5) * -4;
        for (const s of stars) {
          const twinkle = Math.sin(now * 0.001 * s.s * 1000 + s.phase);
          const a = Math.max(0.05, Math.min(0.9, s.baseA + twinkle * 0.25));
          let sx = (s.x + parallaxX) % w;
          let sy = (s.y + parallaxY) % h;
          if (sx < 0) sx += w;
          if (sy < 0) sy += h;
          ctx!.beginPath();
          ctx!.arc(sx, sy, s.r, 0, Math.PI * 2);
          ctx!.fillStyle = 'rgba(208,216,234,' + a + ')';
          ctx!.fill();
        }
        nextShootingStarTime -= dt;
        if (nextShootingStarTime <= 0) {
          shootingStars.push(new ShootingStar(w, h));
          nextShootingStarTime = 3 + Math.random() * 5;
        }
        for (let i = shootingStars.length - 1; i >= 0; i--) {
          const alive = shootingStars[i].update(dt);
          if (alive) {
            shootingStars[i].draw(ctx!);
          } else {
            shootingStars.splice(i, 1);
          }
        }
        animId = requestAnimationFrame(draw);
      }
      animId = requestAnimationFrame(draw);

      // Cleanup on page transition
      document.addEventListener('astro:before-swap', function cleanup() {
        cancelAnimationFrame(animId);
        window.removeEventListener('resize', resize);
        document.removeEventListener('astro:before-swap', cleanup);
      }, { once: true });
    }

    function initClock() {
      const el = document.getElementById('hud-time');
      if (!el) return;
      function u() {
        const d = new Date();
        el!.textContent =
          String(d.getUTCHours()).padStart(2, '0') + ':' +
          String(d.getUTCMinutes()).padStart(2, '0') + ':' +
          String(d.getUTCSeconds()).padStart(2, '0') + ' UTC';
      }
      u();
      const interval = setInterval(u, 1000);
      document.addEventListener('astro:before-swap', function cleanup() {
        clearInterval(interval);
        document.removeEventListener('astro:before-swap', cleanup);
      }, { once: true });
    }

    // Initialize on first load and on each client-side navigation
    document.addEventListener('astro:page-load', () => {
      initStars();
      initClock();
    });
  </script>
</html>

<style is:global>
  /* Star field canvas */
  .stars {
    position: fixed; inset: 0; z-index: 0; pointer-events: none;
  }

  /* Vignette */
  .vignette {
    position: fixed; inset: 0; z-index: 9996; pointer-events: none;
    background: radial-gradient(ellipse at center, transparent 45%, rgba(6, 7, 12, 0.5) 80%, rgba(6, 7, 12, 0.8) 100%);
  }

  /* Subtle grain */
  .grain {
    position: fixed; inset: 0; z-index: 9998; pointer-events: none;
    opacity: 0.025;
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 512 512' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)'/%3E%3C/svg%3E");
    background-size: 200px;
  }

  .page {
    max-width: 840px; margin: 0 auto;
    padding: 0 32px; position: relative; z-index: 1;
  }

  @keyframes fade-up {
    from { opacity: 0; transform: translateY(8px); }
    to { opacity: 1; transform: translateY(0); }
  }

  /* HUD overlay */
  .hud {
    position: fixed; inset: 0; z-index: 9992;
    pointer-events: none; font-family: var(--font-mono);
  }
  .hud-coords {
    position: absolute; top: 20px; left: 24px;
    font-size: 12px; font-weight: 400; letter-spacing: 1px;
    color: var(--text-label);
    display: flex; flex-direction: column; gap: 2px;
  }
  .hud-time {
    position: absolute; top: 20px; right: 24px;
    font-size: 13px; font-weight: 400; letter-spacing: 2px;
    color: var(--accent);
    text-shadow: 0 0 8px var(--accent-glow);
  }
  .hud-status {
    position: absolute; bottom: 20px; left: 24px;
    font-size: 11px; letter-spacing: 3px; text-transform: uppercase;
    color: var(--text-muted);
  }
  .hud-mag {
    position: absolute; bottom: 20px; right: 24px;
    font-size: 11px; letter-spacing: 2px;
    color: var(--text-label);
  }

  /* Crosshair */
  .crosshair {
    position: fixed; top: 50%; left: 50%;
    width: 40px; height: 40px;
    transform: translate(-50%, -50%);
    z-index: 9991; pointer-events: none;
    opacity: 0.08;
  }
  .crosshair::before {
    content: ''; position: absolute;
    top: 50%; left: 0; right: 0;
    height: 1px; background: var(--text);
  }
  .crosshair::after {
    content: ''; position: absolute;
    left: 50%; top: 0; bottom: 0;
    width: 1px; background: var(--text);
  }

  @media (max-width: 600px) {
    .page { padding: 0 20px; }
    .hud-coords { font-size: 8px; top: 12px; left: 14px; }
    .hud-time { top: 12px; right: 14px; font-size: 9px; }
    .hud-status { bottom: 12px; left: 14px; }
    .hud-mag { bottom: 12px; right: 14px; }
    .crosshair { display: none; }
  }
</style>
